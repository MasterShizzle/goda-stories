package main

import (
    "fmt"
    "log"
    "os"
    "io"
    "encoding/binary"
    
    "github.com/hajimehoshi/ebiten/v2"
    "github.com/hajimehoshi/ebiten/v2/ebitenutil"
    "github.com/davecgh/go-spew/spew"
    "github.com/ghostiam/binstruct"
)


func main() {
    filename := "YODESK.DTA"
    path := "data/" + filename
    const tileWidth, tileHeight = 32, 32
    PaletteData := []byte { 
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x8B,0x00,0xC3,0xCF,0x4B,0x00,
        0x8B,0xA3,0x1B,0x00,0x57,0x77,0x00,0x00,0x8B,0xA3,0x1B,0x00,0xC3,0xCF,0x4B,0x00,
        0xFB,0xFB,0xFB,0x00,0xEB,0xE7,0xE7,0x00,0xDB,0xD3,0xD3,0x00,0xCB,0xC3,0xC3,0x00,
        0xBB,0xB3,0xB3,0x00,0xAB,0xA3,0xA3,0x00,0x9B,0x8F,0x8F,0x00,0x8B,0x7F,0x7F,0x00,
        0x7B,0x6F,0x6F,0x00,0x67,0x5B,0x5B,0x00,0x57,0x4B,0x4B,0x00,0x47,0x3B,0x3B,0x00,
        0x33,0x2B,0x2B,0x00,0x23,0x1B,0x1B,0x00,0x13,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,
        0x00,0xC7,0x43,0x00,0x00,0xB7,0x43,0x00,0x00,0xAB,0x3F,0x00,0x00,0x9F,0x3F,0x00,
        0x00,0x93,0x3F,0x00,0x00,0x87,0x3B,0x00,0x00,0x7B,0x37,0x00,0x00,0x6F,0x33,0x00,
        0x00,0x63,0x33,0x00,0x00,0x53,0x2B,0x00,0x00,0x47,0x27,0x00,0x00,0x3B,0x23,0x00,
        0x00,0x2F,0x1B,0x00,0x00,0x23,0x13,0x00,0x00,0x17,0x0F,0x00,0x00,0x0B,0x07,0x00,
        0x4B,0x7B,0xBB,0x00,0x43,0x73,0xB3,0x00,0x43,0x6B,0xAB,0x00,0x3B,0x63,0xA3,0x00,
        0x3B,0x63,0x9B,0x00,0x33,0x5B,0x93,0x00,0x33,0x5B,0x8B,0x00,0x2B,0x53,0x83,0x00,
        0x2B,0x4B,0x73,0x00,0x23,0x4B,0x6B,0x00,0x23,0x43,0x5F,0x00,0x1B,0x3B,0x53,0x00,
        0x1B,0x37,0x47,0x00,0x1B,0x33,0x43,0x00,0x13,0x2B,0x3B,0x00,0x0B,0x23,0x2B,0x00,
        0xD7,0xFF,0xFF,0x00,0xBB,0xEF,0xEF,0x00,0xA3,0xDF,0xDF,0x00,0x8B,0xCF,0xCF,0x00,
        0x77,0xC3,0xC3,0x00,0x63,0xB3,0xB3,0x00,0x53,0xA3,0xA3,0x00,0x43,0x93,0x93,0x00,
        0x33,0x87,0x87,0x00,0x27,0x77,0x77,0x00,0x1B,0x67,0x67,0x00,0x13,0x5B,0x5B,0x00,
        0x0B,0x4B,0x4B,0x00,0x07,0x3B,0x3B,0x00,0x00,0x2B,0x2B,0x00,0x00,0x1F,0x1F,0x00,
        0xDB,0xEB,0xFB,0x00,0xD3,0xE3,0xFB,0x00,0xC3,0xDB,0xFB,0x00,0xBB,0xD3,0xFB,0x00,
        0xB3,0xCB,0xFB,0x00,0xA3,0xC3,0xFB,0x00,0x9B,0xBB,0xFB,0x00,0x8F,0xB7,0xFB,0x00,
        0x83,0xB3,0xF7,0x00,0x73,0xA7,0xFB,0x00,0x63,0x9B,0xFB,0x00,0x5B,0x93,0xF3,0x00,
        0x5B,0x8B,0xEB,0x00,0x53,0x8B,0xDB,0x00,0x53,0x83,0xD3,0x00,0x4B,0x7B,0xCB,0x00,
        0x9B,0xC7,0xFF,0x00,0x8F,0xB7,0xF7,0x00,0x87,0xB3,0xEF,0x00,0x7F,0xA7,0xF3,0x00,
        0x73,0x9F,0xEF,0x00,0x53,0x83,0xCF,0x00,0x3B,0x6B,0xB3,0x00,0x2F,0x5B,0xA3,0x00,
        0x23,0x4F,0x93,0x00,0x1B,0x43,0x83,0x00,0x13,0x3B,0x77,0x00,0x0B,0x2F,0x67,0x00,
        0x07,0x27,0x57,0x00,0x00,0x1B,0x47,0x00,0x00,0x13,0x37,0x00,0x00,0x0F,0x2B,0x00,
        0xFB,0xFB,0xE7,0x00,0xF3,0xF3,0xD3,0x00,0xEB,0xE7,0xC7,0x00,0xE3,0xDF,0xB7,0x00,
        0xDB,0xD7,0xA7,0x00,0xD3,0xCF,0x97,0x00,0xCB,0xC7,0x8B,0x00,0xC3,0xBB,0x7F,0x00,
        0xBB,0xB3,0x73,0x00,0xAF,0xA7,0x63,0x00,0x9B,0x93,0x47,0x00,0x87,0x7B,0x33,0x00,
        0x6F,0x67,0x1F,0x00,0x5B,0x53,0x0F,0x00,0x47,0x43,0x00,0x00,0x37,0x33,0x00,0x00,
        0xFF,0xF7,0xF7,0x00,0xEF,0xDF,0xDF,0x00,0xDF,0xC7,0xC7,0x00,0xCF,0xB3,0xB3,0x00,
        0xBF,0x9F,0x9F,0x00,0xB3,0x8B,0x8B,0x00,0xA3,0x7B,0x7B,0x00,0x93,0x6B,0x6B,0x00,
        0x83,0x57,0x57,0x00,0x73,0x4B,0x4B,0x00,0x67,0x3B,0x3B,0x00,0x57,0x2F,0x2F,0x00,
        0x47,0x27,0x27,0x00,0x37,0x1B,0x1B,0x00,0x27,0x13,0x13,0x00,0x1B,0x0B,0x0B,0x00,
        0xF7,0xB3,0x37,0x00,0xE7,0x93,0x07,0x00,0xFB,0x53,0x0B,0x00,0xFB,0x00,0x00,0x00,
        0xCB,0x00,0x00,0x00,0x9F,0x00,0x00,0x00,0x6F,0x00,0x00,0x00,0x43,0x00,0x00,0x00,
        0xBF,0xBB,0xFB,0x00,0x8F,0x8B,0xFB,0x00,0x5F,0x5B,0xFB,0x00,0x93,0xBB,0xFF,0x00,
        0x5F,0x97,0xF7,0x00,0x3B,0x7B,0xEF,0x00,0x23,0x63,0xC3,0x00,0x13,0x53,0xB3,0x00,
        0x00,0x00,0xFF,0x00,0x00,0x00,0xEF,0x00,0x00,0x00,0xE3,0x00,0x00,0x00,0xD3,0x00,
        0x00,0x00,0xC3,0x00,0x00,0x00,0xB7,0x00,0x00,0x00,0xA7,0x00,0x00,0x00,0x9B,0x00,
        0x00,0x00,0x8B,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x6F,0x00,0x00,0x00,0x63,0x00,
        0x00,0x00,0x53,0x00,0x00,0x00,0x47,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x2B,0x00,
        0x00,0xFF,0xFF,0x00,0x00,0xE3,0xF7,0x00,0x00,0xCF,0xF3,0x00,0x00,0xB7,0xEF,0x00,
        0x00,0xA3,0xEB,0x00,0x00,0x8B,0xE7,0x00,0x00,0x77,0xDF,0x00,0x00,0x63,0xDB,0x00,
        0x00,0x4F,0xD7,0x00,0x00,0x3F,0xD3,0x00,0x00,0x2F,0xCF,0x00,0x97,0xFF,0xFF,0x00,
        0x83,0xDF,0xEF,0x00,0x73,0xC3,0xDF,0x00,0x5F,0xA7,0xCF,0x00,0x53,0x8B,0xC3,0x00,
        0x2B,0x2B,0x00,0x00,0x23,0x23,0x00,0x00,0x1B,0x1B,0x00,0x00,0x13,0x13,0x00,0x00,
        0xFF,0x0B,0x00,0x00,0xFF,0x00,0x4B,0x00,0xFF,0x00,0xA3,0x00,0xFF,0x00,0xFF,0x00,
        0x00,0xFF,0x00,0x00,0x00,0x4B,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0x33,0x2F,0x00,
        0x00,0x00,0xFF,0x00,0x00,0x1F,0x97,0x00,0xDF,0x00,0xFF,0x00,0x73,0x00,0x77,0x00,
        0x6B,0x7B,0xC3,0x00,0x57,0x57,0xAB,0x00,0x57,0x47,0x93,0x00,0x53,0x37,0x7F,0x00,
        0x4F,0x27,0x67,0x00,0x47,0x1B,0x4F,0x00,0x3B,0x13,0x3B,0x00,0x27,0x77,0x77,0x00,
        0x23,0x73,0x73,0x00,0x1F,0x6F,0x6F,0x00,0x1B,0x6B,0x6B,0x00,0x1B,0x67,0x67,0x00,
        0x1B,0x6B,0x6B,0x00,0x1F,0x6F,0x6F,0x00,0x23,0x73,0x73,0x00,0x27,0x77,0x77,0x00,
        0xFF,0xFF,0xEF,0x00,0xF7,0xF7,0xDB,0x00,0xF3,0xEF,0xCB,0x00,0xEF,0xEB,0xBB,0x00,
        0xF3,0xEF,0xCB,0x00,0xE7,0x93,0x07,0x00,0xE7,0x97,0x0F,0x00,0xEB,0x9F,0x17,0x00,
        0xEF,0xA3,0x23,0x00,0xF3,0xAB,0x2B,0x00,0xF7,0xB3,0x37,0x00,0xEF,0xA7,0x27,0x00,
        0xEB,0x9F,0x1B,0x00,0xE7,0x97,0x0F,0x00,0x0B,0xCB,0xFB,0x00,0x0B,0xA3,0xFB,0x00,
        0x0B,0x73,0xFB,0x00,0x0B,0x4B,0xFB,0x00,0x0B,0x23,0xFB,0x00,0x0B,0x73,0xFB,0x00,
        0x00,0x13,0x93,0x00,0x00,0x0B,0xD3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,
    }

    file, err := os.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    reader := binstruct.NewReader(file, binary.LittleEndian, false)

    defer file.Close()
    fmt.Printf("[%s] Opened file\n", filename)

    outputs := make(map[string]interface{})

    // Parse the different sections
    for {
        // Grab section header
        _, section, err := reader.ReadBytes(4)
        if err != nil {
            if err != io.EOF {
                log.Fatal(err)
            }
            fmt.Println("Done.")
            break
        }

        fmt.Printf("[%s] Reading section: %s\n", filename, section)

        switch s := string(section); s {
        case "VERS":
            major, _ := reader.ReadUint16()
            minor, _ := reader.ReadUint16()
            outputs[s] = string(major) + "." + string(minor)
        case "STUP","SNDS","PUZ2","CHAR","CHWP","CAUX","TNAM","TILE":
            sectionLength, _ := reader.ReadUint32()
            _, sectionData, err := reader.ReadBytes(int(sectionLength))
            // outputs[s] = sectionData

            if err != nil {
                fmt.Printf("Error reading section %s\n", section)
                log.Fatal(err)
            }
        case "ZONE":
            zoneCount, _ := reader.ReadUint16()
            zones := make([]*ZoneInfo, int(zoneCount))
            for i := 0; i < int(zoneCount); i++ {
                // dunno what this does
                _, _ = reader.ReadUint16()
                
                zoneLength, _ := reader.ReadUint32()
                
                _, zoneData, _ := reader.ReadBytes(int(zoneLength))

                zones[i] = processZone(zoneData)
            }
            outputs[s] = zones
        case "TILE_NOT_USED":
            // Each tile has 4 bytes for the tile data, plus 32x32 px (0x400)
            sectionLength, _ := reader.ReadUint32()
            numTiles := int(sectionLength) / 0x404

            // Hold the tile flags, for later reference
            tileFlags := make([]string, numTiles)
            
            // Extract tile bits into images
            for i := 0; i < numTiles; i++ {
                flags, _ := reader.ReadUint32()
                // Make a blank image
                tile := image.NewNRGBA(image.Rect(0, 0, tileWidth, tileHeight))
                for j := 0; j < 0x400; j++ {
                    pixelData, _ := reader.ReadByte()
                    pixel := int(pixelData)
                    if pixel == 0 {
                        tile.Set(j % tileWidth, j / tileHeight, color.Transparent)
                    } else {
                        rVal := PaletteData[pixel * 4 + 2]
                        gVal := PaletteData[pixel * 4 + 1]
                        bVal := PaletteData[pixel * 4 + 0]
                        tile.Set(j % tileWidth, j / tileHeight, color.NRGBA{
                            R: rVal,
                            G: gVal,
                            B: bVal,
                            A: 255,
                        })
                    }
                }

                // Pad number with leading zeroes for filename
                tilename := "assets/tiles/tile_"+fmt.Sprintf("%04d",i)+".png"
                
                // Save bit flags, for later analysis
                tileFlags[i] = fmt.Sprintf("%032b",flags)

                // Save the tile
                f, err := os.Create(tilename)
                if err != nil {
                    log.Fatal(err)
                }
                if err := png.Encode(f, tile); err != nil {
                    f.Close()
                    log.Fatal(err)
                }
                if err := f.Close(); err != nil {
                    log.Fatal(err)
                }
            }
            outputs[s] = tileFlags
        case "ENDF":
            // Read whatever odd bytes are left?
            _, err = reader.ReadAll()
            if err != nil {
                log.Fatal(err)
            }
        default:
            fmt.Printf("UNHANDLED CASE: %s\n", section)
            log.Fatal("Unhandled case")
        }
    }

    // output
    spew.Dump(outputs["ZONE"])
}

type ZoneInfo struct {
    Id int
    Type string
    Width int
    Height int
    Layers struct {
        Terrain []int
        Objects []int
        Overlay []int
    }
}

func processZone(zData []byte) *ZoneInfo {
    z := new(ZoneInfo)
    // Sanity check
    zoneHeader := string(zData[2:6])

    z.Id = int(binary.LittleEndian.Uint16(zData[0:]))
    if zoneHeader != "IZON" {
        log.Fatal(fmt.Sprintf("IZON header not found: cannot parse zoneData for zoneId %s", string(z.Id)))
    }

    // Populate a ZoneInfo for this map
    z.Width = int(binary.LittleEndian.Uint16(zData[10:]))
    z.Height = int(binary.LittleEndian.Uint16(zData[12:]))
    p := int(zData[20])
    fmt.Printf("pType is: %d\n", p)
    switch p {
    case 1:
        z.Type = "desert"
    case 2:
        z.Type = "snow"
    case 3:
        z.Type = "forest"
    case 5:
        z.Type = "swamp"
    default:
        z.Type = "UNKNOWN"
    }

    // Grab tiles starting at byte 23: each one has 3x two-byte ints, for 3 tiles / cell
    z.Layers.Terrain = make([]int, z.Width * z.Height)
    z.Layers.Objects = make([]int, z.Width * z.Height)
    z.Layers.Overlay = make([]int, z.Width * z.Height)
    for j := 0; j < (z.Width * z.Height); j++ {
        z.Layers.Terrain[j] = int(binary.LittleEndian.Uint16(zData[6*j + 22:]))
        z.Layers.Objects[j] = int(binary.LittleEndian.Uint16(zData[6*j + 24:]))
        z.Layers.Overlay[j] = int(binary.LittleEndian.Uint16(zData[6*j + 26:]))
    }

    return z
}
