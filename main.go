package main

import (
	"encoding/binary"
	"fmt"
	"image"
	"image/color"
	"image/draw"
	"image/png"
	"io"
	"log"
	"os"

	"github.com/davecgh/go-spew/spew"
	"github.com/ghostiam/binstruct"
	// "github.com/hajimehoshi/ebiten/v2"
)

const tileWidth, tileHeight = 32, 32
const mapInfoFile = "assets/text/mapInfo.txt"
const tileInfoFile = "assets/text/tileInfo.txt"

func main() {
	filename := "YODESK.DTA"
	path := "data/" + filename
	tileFlags := []TileInfo{}

	file, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	reader := binstruct.NewReader(file, binary.LittleEndian, false)

	defer file.Close()
	fmt.Printf("[%s] Opened file\n", filename)

	outputs := make(map[string]interface{})

	// Parse the different sections
	for {
		// Grab section header
		_, section, err := reader.ReadBytes(4)
		if err != nil {
			if err != io.EOF {
				log.Fatal(err)
			}
			fmt.Println("Done.")
			break
		}

		fmt.Printf("[%s] Reading section: %s\n", filename, section)

		switch s := string(section); s {
		case "VERS":
			major, _ := reader.ReadUint16()
			minor, _ := reader.ReadUint16()
			outputs[s] = fmt.Sprint(int(major)) + "." + fmt.Sprint(int(minor))
		case "STUP", "SNDS", "PUZ2", "CHAR", "CHWP", "CAUX", "TNAM":
			// Basically, just skip all these sections
			sectionLength, _ := reader.ReadUint32()
			_, _, err := reader.ReadBytes(int(sectionLength))
			// _, sectionData, err := reader.ReadBytes(int(sectionLength))
			// outputs[s] = sectionData

			if err != nil {
				fmt.Printf("Error reading section %s\n", section)
				log.Fatal(err)
			}
		case "ZONE":
			zoneCount, _ := reader.ReadUint16()
			zones := make([]ZoneInfo, int(zoneCount))
			for i := 0; i < int(zoneCount); i++ {
				// dunno what this does
				_, _ = reader.ReadUint16()

				zoneLength, _ := reader.ReadUint32()

				_, zoneData, _ := reader.ReadBytes(int(zoneLength))

				zones[i] = processZoneData(zoneData, tileFlags)
			}
			outputs[s] = zones
		case "TILE":
			// Each tile has 4 bytes for the tile data, plus 32x32 px (0x400)
			sectionLength, _ := reader.ReadUint32()
			numTiles := int(sectionLength) / 0x404
			tileFlags = make([]TileInfo, numTiles)

			skipped := 0

			// Extract tile bits into images
			for i := 0; i < numTiles; i++ {
				// Pad number with leading zeroes for filename
				tilename := "assets/tiles/tile_" + fmt.Sprintf("%04d", i) + ".png"
				flags, _ := reader.ReadUint32()
				tileFlags[i] = TileInfo{}
				tileFlags[i].Id = fmt.Sprintf("%04d", i)
				tileFlags[i].Flags = fmt.Sprintf("%032b", flags)

				// Skip creating the tile if it's already done
				_, err := os.Stat(tilename)
				if err == nil {
					skipped++
					reader.ReadBytes(0x400)
					fmt.Printf(".")
					continue
				} else {
					_, tileBytes, _ := reader.ReadBytes(0x400)
					err = saveByteSliceToPNG(tilename, tileBytes)
					if err != nil {
						log.Fatal(err)
					}
					fmt.Printf("*")
				}
			}
			fmt.Printf("]\n    %d tiles extracted, %d skipped.\n", numTiles-skipped, skipped)
		case "ENDF":
			// Read whatever odd bytes are left?
			_, err = reader.ReadAll()
			if err != nil {
				log.Fatal(err)
			}
		default:
			fmt.Printf("UNHANDLED CASE: %s\n", section)
			log.Fatal("Unhandled case")
		}
	}

	// output map info to file
	fmt.Printf("\n")
	fmt.Printf("[%s] Stitching maps... \n    [", filename)
	numZones := len(outputs["ZONE"].([]ZoneInfo))
	skipped := 0

	mapInfo, err := os.Create(mapInfoFile)
	if err != nil {
		log.Fatal(err)
	}
	tileInfo, err := os.Create(tileInfoFile)
	if err != nil {
		log.Fatal(err)
	}

	for zId, zData := range outputs["ZONE"].([]ZoneInfo) {
		// Save map image and zone data
		mapName := "assets/maps/map_" + fmt.Sprintf("%03d", zId) + ".png"
		_, err := os.Stat(mapName)
		if err == nil {
			// Skip creating the map if it's already done
			skipped++
			fmt.Printf(".")
		} else {
			// Otherwise, stitch the map together and save it
			err = saveMapToPNG(mapName, zData)
			if err != nil {
				log.Fatal(err)
			}
			fmt.Printf("*")
		}

		// Prune the map layers, so the output is cleaner
		outputs["ZONE"].([]ZoneInfo)[zId].Layers.Terrain = nil
		outputs["ZONE"].([]ZoneInfo)[zId].Layers.Objects = nil
		outputs["ZONE"].([]ZoneInfo)[zId].Layers.Overlay = nil
	}
	fmt.Println("]")
	fmt.Printf("    %d maps extracted, %d skipped.\n", numZones-skipped, skipped)

	fmt.Printf("Dumping output to %s...\n", mapInfoFile)
	spew.Fdump(mapInfo, outputs["ZONE"])

	fmt.Printf("Dumping output to %s...\n", tileInfoFile)
	spew.Fdump(tileInfo, tileFlags)
}

type ZoneInfo struct {
	Id     int
	Type   string
	Width  int
	Height int
	Flags  string
	Layers struct {
		Terrain []int
		Objects []int
		Overlay []int
	}
	ObjectTriggers []ObjectTrigger
}

type TileInfo struct {
	Id          string
	Flags       string
	IsObject    bool
	IsTerrain   bool
	IsColliding bool
	CanPush     bool
	IsOverlay   bool
	IsMiniMap   bool
	IsWeapon    bool
	IsItem      bool
	IsCharacter bool
}

type ObjectTrigger struct {
	Type        string
	X           int
	Y           int
	Arg         int
	TerrainInfo TileInfo
	ObjectInfo  TileInfo
	OverlayInfo TileInfo
}

func processZoneData(zData []byte, tiles []TileInfo) ZoneInfo {
	z := new(ZoneInfo)

	// Sanity check
	zoneHeader := string(zData[2:6])
	z.Id = int(binary.LittleEndian.Uint16(zData[0:]))
	if zoneHeader != "IZON" {
		log.Fatal(fmt.Sprintf("IZON header not found: cannot parse zoneData for zoneId %s", fmt.Sprint(z.Id)))
	}

	fmt.Printf("    Processing map_%03d: ", z.Id)

	// Populate a ZoneInfo for this map
	z.Width = int(binary.LittleEndian.Uint16(zData[10:]))
	z.Height = int(binary.LittleEndian.Uint16(zData[12:]))
	z.Flags = fmt.Sprintf("%08b", zData[14])

	p := int(zData[20])
	switch p {
	case 1:
		z.Type = "desert"
	case 2:
		z.Type = "snow"
	case 3:
		z.Type = "forest"
	case 5:
		z.Type = "swamp"
	default:
		z.Type = "UNKNOWN"
	}

	// Grab tiles starting at byte 22: each one has 3x two-byte ints, for 3 tiles / cell
	z.Layers.Terrain = make([]int, z.Width*z.Height)
	z.Layers.Objects = make([]int, z.Width*z.Height)
	z.Layers.Overlay = make([]int, z.Width*z.Height)
	for j := 0; j < (z.Width * z.Height); j++ {
		z.Layers.Terrain[j] = int(binary.LittleEndian.Uint16(zData[6*j+22:]))
		z.Layers.Objects[j] = int(binary.LittleEndian.Uint16(zData[6*j+24:]))
		z.Layers.Overlay[j] = int(binary.LittleEndian.Uint16(zData[6*j+26:]))
	}

	// Parse entries for object info
	triggerTypes := []string{
		"trigger_location",
		"spawn_location",
		"force_location",
		"vehicle_to_secondary_map",
		"vehicle_to_primary_map",
		"object_gives_locator",
		"crate_with_item",
		"puzzle_NPC",
		"crate_with_weapon",
		"map_entrance",
		"map_exit",
		"unused",
		"lock",
		"teleporter",
		"xwing_from_dagobah",
		"xwing_to_dagobah",
		"UNKNOWN",
	}
	objInfoAddress := (6 * z.Width * z.Height) + 22
	numTriggers := int(binary.LittleEndian.Uint16(zData[objInfoAddress:]))
	fmt.Printf(" Processing %d triggers", numTriggers)
	if numTriggers > 0 {
		z.ObjectTriggers = make([]ObjectTrigger, numTriggers)
		for k := 0; k < numTriggers; k++ {
			fmt.Printf(".")
			offset := objInfoAddress + (12 * k)
			z.ObjectTriggers[k].Type = triggerTypes[int(binary.LittleEndian.Uint16(zData[offset+2:]))]
			z.ObjectTriggers[k].X = int(binary.LittleEndian.Uint16(zData[offset+6:]))
			z.ObjectTriggers[k].Y = int(binary.LittleEndian.Uint16(zData[offset+8:]))
			z.ObjectTriggers[k].Arg = int(binary.LittleEndian.Uint16(zData[offset+12:]))
			tnum := z.Layers.Terrain[(z.Width*z.ObjectTriggers[k].Y)+z.ObjectTriggers[k].X]
			if tnum != 65535 {
				z.ObjectTriggers[k].TerrainInfo = tiles[tnum]
			}
			tnum = z.Layers.Objects[(z.Width*z.ObjectTriggers[k].Y)+z.ObjectTriggers[k].X]
			if tnum != 65535 {
				z.ObjectTriggers[k].ObjectInfo = tiles[tnum]
			}
			tnum = z.Layers.Overlay[(z.Width*z.ObjectTriggers[k].Y)+z.ObjectTriggers[k].X]
			if tnum != 65535 {
				z.ObjectTriggers[k].OverlayInfo = tiles[tnum]
			}
		}
	}
	fmt.Println()

	return *z
}

func saveMapToPNG(mapPath string, zone ZoneInfo) error {
	// Make a blank map and fill with black
	mapImage := image.NewRGBA(image.Rect(0, 0, zone.Width*tileWidth, zone.Height*tileHeight))
	draw.Draw(mapImage, mapImage.Bounds(), image.Black, image.Black.Bounds().Max, draw.Src)

	// Draw tiles
	for i := 0; i < (zone.Width * zone.Height); i++ {
		terrainTile, err := getTileByNumber(zone.Layers.Terrain[i])
		if err != nil {
			log.Fatal(err)
		}

		objectsTile, err := getTileByNumber(zone.Layers.Objects[i])
		if err != nil {
			log.Fatal(err)
		}

		overlayTile, err := getTileByNumber(zone.Layers.Overlay[i])
		if err != nil {
			log.Fatal(err)
		}

		x := (i % zone.Width) * tileWidth
		y := (i / zone.Height) * tileHeight

		offset := image.Pt(x, y)

		if terrainTile != nil {
			draw.Draw(mapImage, mapImage.Bounds().Add(offset), terrainTile, image.Pt(0, 0), draw.Src)
		}
		if objectsTile != nil {
			draw.Draw(mapImage, mapImage.Bounds().Add(offset), objectsTile, image.Pt(0, 0), draw.Over)
		}
		if overlayTile != nil {
			draw.Draw(mapImage, mapImage.Bounds().Add(offset), overlayTile, image.Pt(0, 0), draw.Over)
		}
	}

	f, err := os.Create(mapPath)
	if err != nil {
		return err
	}
	if err := png.Encode(f, mapImage); err != nil {
		f.Close()
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}
	return nil
}

func getTileByNumber(tileNum int) (image.Image, error) {
	// Get the tile from its .png image source, by number
	blankTile := image.NewRGBA(image.Rect(0, 0, tileWidth, tileHeight))
	draw.Draw(blankTile, image.Rect(0, 0, tileWidth, tileHeight), image.Transparent, image.Pt(0, 0), draw.Src)
	filePath := "assets/tiles/tile_" + fmt.Sprintf("%04d", tileNum) + ".png"
	if tileNum == 65535 { // return a transparent tile
		return blankTile, nil
	}
	f, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	image, _, err := image.Decode(f)
	return image, err
}

func saveByteSliceToPNG(tPath string, tData []byte) error {
	// Palette data extracted from the de-compiled Yoda Stories binary
	PaletteData := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x8B, 0x00, 0xC3, 0xCF, 0x4B, 0x00,
		0x8B, 0xA3, 0x1B, 0x00, 0x57, 0x77, 0x00, 0x00, 0x8B, 0xA3, 0x1B, 0x00, 0xC3, 0xCF, 0x4B, 0x00,
		0xFB, 0xFB, 0xFB, 0x00, 0xEB, 0xE7, 0xE7, 0x00, 0xDB, 0xD3, 0xD3, 0x00, 0xCB, 0xC3, 0xC3, 0x00,
		0xBB, 0xB3, 0xB3, 0x00, 0xAB, 0xA3, 0xA3, 0x00, 0x9B, 0x8F, 0x8F, 0x00, 0x8B, 0x7F, 0x7F, 0x00,
		0x7B, 0x6F, 0x6F, 0x00, 0x67, 0x5B, 0x5B, 0x00, 0x57, 0x4B, 0x4B, 0x00, 0x47, 0x3B, 0x3B, 0x00,
		0x33, 0x2B, 0x2B, 0x00, 0x23, 0x1B, 0x1B, 0x00, 0x13, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xC7, 0x43, 0x00, 0x00, 0xB7, 0x43, 0x00, 0x00, 0xAB, 0x3F, 0x00, 0x00, 0x9F, 0x3F, 0x00,
		0x00, 0x93, 0x3F, 0x00, 0x00, 0x87, 0x3B, 0x00, 0x00, 0x7B, 0x37, 0x00, 0x00, 0x6F, 0x33, 0x00,
		0x00, 0x63, 0x33, 0x00, 0x00, 0x53, 0x2B, 0x00, 0x00, 0x47, 0x27, 0x00, 0x00, 0x3B, 0x23, 0x00,
		0x00, 0x2F, 0x1B, 0x00, 0x00, 0x23, 0x13, 0x00, 0x00, 0x17, 0x0F, 0x00, 0x00, 0x0B, 0x07, 0x00,
		0x4B, 0x7B, 0xBB, 0x00, 0x43, 0x73, 0xB3, 0x00, 0x43, 0x6B, 0xAB, 0x00, 0x3B, 0x63, 0xA3, 0x00,
		0x3B, 0x63, 0x9B, 0x00, 0x33, 0x5B, 0x93, 0x00, 0x33, 0x5B, 0x8B, 0x00, 0x2B, 0x53, 0x83, 0x00,
		0x2B, 0x4B, 0x73, 0x00, 0x23, 0x4B, 0x6B, 0x00, 0x23, 0x43, 0x5F, 0x00, 0x1B, 0x3B, 0x53, 0x00,
		0x1B, 0x37, 0x47, 0x00, 0x1B, 0x33, 0x43, 0x00, 0x13, 0x2B, 0x3B, 0x00, 0x0B, 0x23, 0x2B, 0x00,
		0xD7, 0xFF, 0xFF, 0x00, 0xBB, 0xEF, 0xEF, 0x00, 0xA3, 0xDF, 0xDF, 0x00, 0x8B, 0xCF, 0xCF, 0x00,
		0x77, 0xC3, 0xC3, 0x00, 0x63, 0xB3, 0xB3, 0x00, 0x53, 0xA3, 0xA3, 0x00, 0x43, 0x93, 0x93, 0x00,
		0x33, 0x87, 0x87, 0x00, 0x27, 0x77, 0x77, 0x00, 0x1B, 0x67, 0x67, 0x00, 0x13, 0x5B, 0x5B, 0x00,
		0x0B, 0x4B, 0x4B, 0x00, 0x07, 0x3B, 0x3B, 0x00, 0x00, 0x2B, 0x2B, 0x00, 0x00, 0x1F, 0x1F, 0x00,
		0xDB, 0xEB, 0xFB, 0x00, 0xD3, 0xE3, 0xFB, 0x00, 0xC3, 0xDB, 0xFB, 0x00, 0xBB, 0xD3, 0xFB, 0x00,
		0xB3, 0xCB, 0xFB, 0x00, 0xA3, 0xC3, 0xFB, 0x00, 0x9B, 0xBB, 0xFB, 0x00, 0x8F, 0xB7, 0xFB, 0x00,
		0x83, 0xB3, 0xF7, 0x00, 0x73, 0xA7, 0xFB, 0x00, 0x63, 0x9B, 0xFB, 0x00, 0x5B, 0x93, 0xF3, 0x00,
		0x5B, 0x8B, 0xEB, 0x00, 0x53, 0x8B, 0xDB, 0x00, 0x53, 0x83, 0xD3, 0x00, 0x4B, 0x7B, 0xCB, 0x00,
		0x9B, 0xC7, 0xFF, 0x00, 0x8F, 0xB7, 0xF7, 0x00, 0x87, 0xB3, 0xEF, 0x00, 0x7F, 0xA7, 0xF3, 0x00,
		0x73, 0x9F, 0xEF, 0x00, 0x53, 0x83, 0xCF, 0x00, 0x3B, 0x6B, 0xB3, 0x00, 0x2F, 0x5B, 0xA3, 0x00,
		0x23, 0x4F, 0x93, 0x00, 0x1B, 0x43, 0x83, 0x00, 0x13, 0x3B, 0x77, 0x00, 0x0B, 0x2F, 0x67, 0x00,
		0x07, 0x27, 0x57, 0x00, 0x00, 0x1B, 0x47, 0x00, 0x00, 0x13, 0x37, 0x00, 0x00, 0x0F, 0x2B, 0x00,
		0xFB, 0xFB, 0xE7, 0x00, 0xF3, 0xF3, 0xD3, 0x00, 0xEB, 0xE7, 0xC7, 0x00, 0xE3, 0xDF, 0xB7, 0x00,
		0xDB, 0xD7, 0xA7, 0x00, 0xD3, 0xCF, 0x97, 0x00, 0xCB, 0xC7, 0x8B, 0x00, 0xC3, 0xBB, 0x7F, 0x00,
		0xBB, 0xB3, 0x73, 0x00, 0xAF, 0xA7, 0x63, 0x00, 0x9B, 0x93, 0x47, 0x00, 0x87, 0x7B, 0x33, 0x00,
		0x6F, 0x67, 0x1F, 0x00, 0x5B, 0x53, 0x0F, 0x00, 0x47, 0x43, 0x00, 0x00, 0x37, 0x33, 0x00, 0x00,
		0xFF, 0xF7, 0xF7, 0x00, 0xEF, 0xDF, 0xDF, 0x00, 0xDF, 0xC7, 0xC7, 0x00, 0xCF, 0xB3, 0xB3, 0x00,
		0xBF, 0x9F, 0x9F, 0x00, 0xB3, 0x8B, 0x8B, 0x00, 0xA3, 0x7B, 0x7B, 0x00, 0x93, 0x6B, 0x6B, 0x00,
		0x83, 0x57, 0x57, 0x00, 0x73, 0x4B, 0x4B, 0x00, 0x67, 0x3B, 0x3B, 0x00, 0x57, 0x2F, 0x2F, 0x00,
		0x47, 0x27, 0x27, 0x00, 0x37, 0x1B, 0x1B, 0x00, 0x27, 0x13, 0x13, 0x00, 0x1B, 0x0B, 0x0B, 0x00,
		0xF7, 0xB3, 0x37, 0x00, 0xE7, 0x93, 0x07, 0x00, 0xFB, 0x53, 0x0B, 0x00, 0xFB, 0x00, 0x00, 0x00,
		0xCB, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00,
		0xBF, 0xBB, 0xFB, 0x00, 0x8F, 0x8B, 0xFB, 0x00, 0x5F, 0x5B, 0xFB, 0x00, 0x93, 0xBB, 0xFF, 0x00,
		0x5F, 0x97, 0xF7, 0x00, 0x3B, 0x7B, 0xEF, 0x00, 0x23, 0x63, 0xC3, 0x00, 0x13, 0x53, 0xB3, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xD3, 0x00,
		0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 0xB7, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 0x9B, 0x00,
		0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x63, 0x00,
		0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x2B, 0x00,
		0x00, 0xFF, 0xFF, 0x00, 0x00, 0xE3, 0xF7, 0x00, 0x00, 0xCF, 0xF3, 0x00, 0x00, 0xB7, 0xEF, 0x00,
		0x00, 0xA3, 0xEB, 0x00, 0x00, 0x8B, 0xE7, 0x00, 0x00, 0x77, 0xDF, 0x00, 0x00, 0x63, 0xDB, 0x00,
		0x00, 0x4F, 0xD7, 0x00, 0x00, 0x3F, 0xD3, 0x00, 0x00, 0x2F, 0xCF, 0x00, 0x97, 0xFF, 0xFF, 0x00,
		0x83, 0xDF, 0xEF, 0x00, 0x73, 0xC3, 0xDF, 0x00, 0x5F, 0xA7, 0xCF, 0x00, 0x53, 0x8B, 0xC3, 0x00,
		0x2B, 0x2B, 0x00, 0x00, 0x23, 0x23, 0x00, 0x00, 0x1B, 0x1B, 0x00, 0x00, 0x13, 0x13, 0x00, 0x00,
		0xFF, 0x0B, 0x00, 0x00, 0xFF, 0x00, 0x4B, 0x00, 0xFF, 0x00, 0xA3, 0x00, 0xFF, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0x33, 0x2F, 0x00,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0x1F, 0x97, 0x00, 0xDF, 0x00, 0xFF, 0x00, 0x73, 0x00, 0x77, 0x00,
		0x6B, 0x7B, 0xC3, 0x00, 0x57, 0x57, 0xAB, 0x00, 0x57, 0x47, 0x93, 0x00, 0x53, 0x37, 0x7F, 0x00,
		0x4F, 0x27, 0x67, 0x00, 0x47, 0x1B, 0x4F, 0x00, 0x3B, 0x13, 0x3B, 0x00, 0x27, 0x77, 0x77, 0x00,
		0x23, 0x73, 0x73, 0x00, 0x1F, 0x6F, 0x6F, 0x00, 0x1B, 0x6B, 0x6B, 0x00, 0x1B, 0x67, 0x67, 0x00,
		0x1B, 0x6B, 0x6B, 0x00, 0x1F, 0x6F, 0x6F, 0x00, 0x23, 0x73, 0x73, 0x00, 0x27, 0x77, 0x77, 0x00,
		0xFF, 0xFF, 0xEF, 0x00, 0xF7, 0xF7, 0xDB, 0x00, 0xF3, 0xEF, 0xCB, 0x00, 0xEF, 0xEB, 0xBB, 0x00,
		0xF3, 0xEF, 0xCB, 0x00, 0xE7, 0x93, 0x07, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0xEB, 0x9F, 0x17, 0x00,
		0xEF, 0xA3, 0x23, 0x00, 0xF3, 0xAB, 0x2B, 0x00, 0xF7, 0xB3, 0x37, 0x00, 0xEF, 0xA7, 0x27, 0x00,
		0xEB, 0x9F, 0x1B, 0x00, 0xE7, 0x97, 0x0F, 0x00, 0x0B, 0xCB, 0xFB, 0x00, 0x0B, 0xA3, 0xFB, 0x00,
		0x0B, 0x73, 0xFB, 0x00, 0x0B, 0x4B, 0xFB, 0x00, 0x0B, 0x23, 0xFB, 0x00, 0x0B, 0x73, 0xFB, 0x00,
		0x00, 0x13, 0x93, 0x00, 0x00, 0x0B, 0xD3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	}

	// Make a blank image
	tile := image.NewNRGBA(image.Rect(0, 0, tileWidth, tileHeight))

	// Set pixels
	for j := 0; j < len(tData); j++ {
		pixel := int(tData[j])
		if pixel == 0 {
			tile.Set(j%tileWidth, j/tileHeight, color.Transparent)
		} else {
			rVal := PaletteData[pixel*4+2]
			gVal := PaletteData[pixel*4+1]
			bVal := PaletteData[pixel*4+0]
			tile.Set(j%tileWidth, j/tileHeight, color.NRGBA{
				R: rVal,
				G: gVal,
				B: bVal,
				A: 255,
			})
		}
	}

	// Save tiles to .png
	f, err := os.Create(tPath)
	if err != nil {
		return err
	}
	if err := png.Encode(f, tile); err != nil {
		f.Close()
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}

	return nil
}
